# Programmers Level 2

### 81303 문제링크

[81303 - 표 편집](https://school.programmers.co.kr/learn/courses/30/lessons/81303)

### Comment

stack을 활용한 문제 <br>
이번 문제는 풀지 못했다. 인덱스를 자유자재로 활용해야하는데 자꾸 배열 자체에 삽입/삭제/추가를 하려고 하니 문제를 풀 수 없었다.

## 인덱스를 활용하자!

해석을 봤는데도 이해하는데 오래 걸린 문제였다.
문제는 cmd가 전부 수행되었을 때 처음 표와 비교해서 각 행이 삭제되었는지 여부를 알아내야 했다. 즉, 결과론적으로 각 행에 어떤 데이터가 있는지는 전혀 중요하지 않다. <br>

> 내부의 데이터가 어떤건지 중요하지 않고 실제 배열을 삽입/삭제해야 하는 문제의 경우 대부분 인덱스를 활용해서 푸는 것 같다.

문제에 나온 표를 보면 하나를 삭제하면 삭제된 행의 위아래 행이 영향을 받는다. 따라서 up, down 시 각 행을 기준으로 명령이 끝난 후의 위치 정보를 파악해야한다.

- `up`: U 명령어 수행 후의 위치
- `down`: D 명령어 수행 후의 위치

| k    | 0   | 1   | 2   | 3   | 4   |
| ---- | --- | --- | --- | --- | --- |
| up   | -1  | 0   | 1   | 2   | 3   |
| down | 1   | 2   | 3   | 4   | 5   |

## 배열 요소를 삭제하지 않고도 인덱스를 활용해서 삭제가 된 것처럼 만드는 방법

k가 삭제되면 k 아래 행은 k 바로 윗 행의 아래 행이 되고 k 아래 행의 윗 행은 k의 윗부분이 되야 한다.
그리고 복구할 때를 위해서 스택에 삭제된 행을 push해준다.

```js
deleted.push(k);
up[down[k]] = up[k]; // k 아래 행의 윗 행은 k의 윗행
down[up[k]] = down[k]; // k 윗 행의 아래 행은 k의 아래 행
k = n < down[k] ? up[k] : down[k]; // 전체 표 길이보다 아래행이 더 클 경우 한칸 위로
```

## 배열 요소의 각 인덱스를 바꾸지 않고도 인텍스를 활용해서 복구하는 경우

```js
const reverted = deleted.pop();
up[down[reverted]] = reverted; // 회복한 행의 아래 행의 위는 회복한 행이다.
down[up[reverted]] = reverted; // 회복한 행의 윗 행의 아래 행은 회복한 행이다.
```

## 표 양끝에서 명령어 수행하는 경우 생각해야함

테이블의 맨 위, 아래에서도 추가/삭제를 할 수 있는데 위에서 세워둔 식은 아래와 같은 예외 케이스에 대비하지 않은 상태다.

```js
deleted.push(0);
up[down[0]] = up[0]; // up[1] = -1;
down[up[0]] = down[k]; // down[-1] = 1; // 비정상적인 인덱스 접근

deleted.push(7);
up[down[7]] = up[7]; // up[8] = 6; // 8은 없는 인덱싱
down[up[7]] = down[7]; // down[6] = ? // down[7]도 없는 존재하지 않는 값
```

k는 항상 1 이상이고 정해진 행 개수보다 k-1 보다 작아야 한다. 즉, 처음과 마지막 인덱싱 접근을 막아야 한다. 때문에 양 끝에서 명령어를 수행할 때도 정상적으로 위 식이 적용되게 **가상공간을 도입하면 된다.**

## 가상 공간 추가

| k    | 0   | 1   | 2   | 3   | 4   | (5) | (6) |
| ---- | --- | --- | --- | --- | --- | --- | --- |
| up   | -1  | 0   | 1   | 2   | 3   | (4) | (5) |
| down | 1   | 2   | 3   | 4   | 5   | (6) |     |

```js
const up = [...new Array(n + 2)].map((_, i) => i - 1);
const down = [...new Array(n + 1)].map((_, i) => i + 1);
```

왜 up은 +2의 가상공간을 만들어줬을까?
마지막 행 k를 삭제하면 (만약 4라고 가정) 아래와 같이 없는 인덱스를 참조해야 하기 떄문이다.

```js
up[down[4]] = up[4]; // 없는 up[5]를 참조할 수 있다.
down[up[4]] = down[4]; // down[undefined] = 5
```

## 가상 공간 추가 후 인덱스는 +1 부터

이렇게 하고나면 기존 테이블의 첫번째 행은 임시공간이 생긴 새로운 테이블의 두번째 행에 해당한다.
따라서 문제에 주어진 초기 위치 k는 1을 더해서 시작해야한다. 그리고 명령어를 다 돌린 이후에 남은 deleted에 있는 행번호는 초기에 더했던 1을 빼주면서 answer을 만든다.

## 마지막 행 삭제하는 경우 고려

```js
// 삭제 커맨드 C의 경우
deleted.push(k);
up[down[k]] = up[k];
down[up[k]] = down[k];
k = n < down[k] ? up[k] : down[k]; // k 아래 행이 n보다 큰 경우 대비
```
